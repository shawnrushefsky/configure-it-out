/**
 * Generated by shawnrushefsky/typedef
 * https://github.com/shawnrushefsky/typedef
 * @typedef {{
 *   name: string
 *   dn: string
 *   type: string
 *   masks: Array<{
 *     claim: string
 *     mask: number
 *   }>
 *   unmasks: Array<{
 *     claim: string
 *     mask: number
 *   }>,
 *   legacy: boolean,
 *   description: string
 * }} AuthDescriptor
 */

const config = {
  /**
   * It is helpful to derive the healthcheck from the environment
   * to avoid config mismatch.
   * */
  healthcheck: process.env.HEALTHCHECK ?? "/healthcheck",

  // Your app should always accept a port override via the PORT envvar
  port: Number(process.env.PORT) || 3000,

  sha: process.env.GITHUB_SHA ?? "unknown",

  identityHeader: process.env.USER_IDENTITY_HEADER ?? "x-identity",

  logLevel: process.env.LOG_LEVEL ?? "error",

  clusterMap: {
    bucket: process.env.CLUSTER_MAP_BUCKET ?? "static.glgresearch.com",
    key: process.env.CLUSTER_MAP_KEY ?? "gds-cluster-map/cluster-map.json",
    region: process.env.CLUSTER_MAP_REGION ?? "us-west-2",
  },

  githubUsernameMap:
    process.env.GITHUB_USERNAME_TO_EMAIL_URL ||
    "https://services-internal.glgresearch.com/kvstores/kv/sre/github-username-to-email",

  github: {
    owners: process.env.GITHUB_OWNERS
      ? process.env.GITHUB_OWNERS.split(",")
      : ["glg", "glg-public"],
    epiqueryTemplateRepo:
      process.env.EPIQUERY_TEMPLATE_REPO ?? "glg/epiquery-templates",
    token: process.env.GITHUB_TOKEN,
  },

  aws: {
    accountId: process.env.AWS_ACCOUNT_ID ?? 868468680417,
    accountName: process.env.AWS_ACCOUNT_NAME ?? "glgapp",
    partition: process.env.AWS_PARTITION ?? "aws",
    region:
      process.env.AWS_REGION ?? process.env.AWS_DEFAULT_REGION ?? "us-east-1",
    accountMapping: {},
  },

  documentation: {
    baseURL:
      process.env.DOCUMENTATION_BASE_URL ??
      "https://services.glgresearch.com/know/glg-deployment-system-gds",
    fqdn:
      process.env.DOCUMENTATION_FQDN ?? "/cluster-configuration/#env-gds-fqdn",
    env:
      process.env.DOCUMENTATION_ENV ??
      "/cluster-configuration/#environment-configurations",
    schedule:
      process.env.DOCUMENATION_SCHEDULE ??
      "/cluster-configuration/#env-ecs-scheduled-task-cron",
  },

  dynamo: {
    endpoint: process.env.DYNAMO_ENDPOINT ?? "http://localhost:8000",
    fileTable: process.env.DYNAMO_FILES_TABLE ?? "deployinator-cache-files",
    repoTable: process.env.DYNAMO_REPO_TABLE ?? "deployinator-cache-repos",
    kvTable: process.env.DYNAMO_KV_TABLE ?? "deployinator-cache-kv",
    deploymentsTable:
      process.env.DYNAMO_DEPLOYMENTS_TABLE ?? "deployinator-cache-deployments",
  },

  opensearch: {
    deploymentsIndex:
      process.env.OPENSEARCH_DEPLOYMENTS_INDEX ?? "deployments-v1",
    /**
     * !!THIS IS FOR LOCAL ONLY!!
     * For the love of god do not use these
     * credentials in production
     */
    username: process.env.OPENSEARCH_USERNAME ?? "admin",
    password: process.env.OPENSEARCH_PASSWORD ?? "admin",
    host: process.env.OPENSEARCH_HOST ?? "localhost",
    port: Number(process.env.OPENSEARCH_PORT) || 9200,
    protocol: process.env.OPENSEARCH_PROTOCOL ?? "http",
  },

  cacheBeforeStart: process.env.CACHE_BEFORE_START === "true",
  skipCache: process.env.SKIP_CACHE !== "false",

  rbac: {
    canSeeLegacy: process.env.ROLES_THAT_CAN_SEE_LEGACY
      ? process.env.ROLES_THAT_CAN_SEE_LEGACY.split(",")
      : [],
    secrets: {},
  },

  roles: {
    flagsRepo: process.env.ACCESS_FLAGS_REPO ?? "glg/gds-session",
    flagsFile: process.env.ACCESS_FLAGS_FILE ?? "flags.json",
    flagsBranch: process.env.ACCESS_FLAGS_BRANCH ?? "main",
    tokensRepo: process.env.APP_TOKEN_REPO ?? "glg/app-tokens",
    tokensBranch: process.env.APP_TOKEN_BRANCH ?? "main",
    /**
     * @type Array<AuthDescriptor>
     */
    legacy: [
      {
        name: "Deny All",
        masks: [
          {
            claim: "role-glg",
            mask: 0,
          },
        ],
        type: "legacy",
        description: "Formerly GLG_DENY_ALL",
      },
      {
        name: "GLG Employees",
        masks: [
          {
            claim: "role-glg",
            mask: 1,
          },
        ],
        type: "legacy",
        description: "Formerly GLG_USER",
      },
      {
        name: "Clients",
        masks: [
          {
            claim: "role-glg",
            mask: 2,
          },
        ],
        type: "legacy",
        description: "Formerly GLG_CLIENT",
      },
      {
        name: "Council Members",
        masks: [
          {
            claim: "role-glg",
            mask: 4,
          },
        ],
        type: "legacy",
        description: "Formerly GLG_COUNCILMEMBER",
      },
      {
        name: "Survey Respondent",
        masks: [
          {
            claim: "role-glg",
            mask: 8,
          },
        ],
        type: "legacy",
        description: "Formerly GLG_SURVEYRESPONDENT",
      },
      {
        name: "External Applications",
        masks: [
          {
            claim: "role-glg",
            mask: 16,
          },
        ],
        type: "legacy",
        description: "Formerly GLG_APP",
      },
      {
        name: "External Worker",
        masks: [
          {
            claim: "role-glg",
            mask: 32,
          },
        ],
        type: "legacy",
        description: "Formerly GLG_EXTERNAL_WORKER",
      },
      {
        name: "Allow All",
        masks: [
          {
            claim: "role-glg",
            mask: 2147483647,
          },
        ],
        type: "legacy",
        description: "Formerly GLG_ALLOW_ALL",
      },
    ],
  },
};

if (process.env.PRIVATE_SECRET_NAMESPACES) {
  const allSets = process.env.PRIVATE_SECRET_NAMESPACES.split("|");
  allSets.forEach((set) => {
    const [namespace, allRoles] = set.split(":");
    config.rbac.secrets[namespace] = allRoles.split(",");
  });
}

config.aws.accountMapping[config.aws.accountName] = {
  accountId: config.aws.accountId,
  partition: config.aws.partition,
  region: config.aws.region,
  isDefault: true,
};

/**
 * Pre-process this value into something more useable
 */
if (process.env.MANAGED_AWS_ACCOUNTS) {
  const allSets = process.env.MANAGED_AWS_ACCOUNTS.split(",");
  const roleArn = /arn:(?<partition>[\w-]+):iam::(?<id>\d+):role\/(?<role>.+)/;
  allSets.forEach((set) => {
    const [accountName, arn] = set.split("=");
    const match = roleArn.exec(arn);
    if (match) {
      const { partition, id, role } = match.groups;
      config.aws.accountMapping[accountName] = {
        partition,
        accountId: id,
        role,
        region: config.aws.region,
      };
    } else {
      console.log(
        JSON.stringify({
          message: `INVALID ROLE ARN: ${arn}`,
          sha: config.sha,
          level: "error",
        })
      );
    }
  });
}

export default config;
